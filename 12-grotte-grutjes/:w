#!/bin/env python3

from collections import defaultdict


def load_routes(path):
  routes = defaultdict(list)
  with open(path, "r") as f:
    for line in f:
      [from_, to_] = line.strip().split("-")
      routes[from_].append(to_)
      routes[to_].append(from_)
  return routes


def is_small(cave):
  return cave.islower()


def qualify_maximum_visits(routes):
  single_caves = [c for c,r in routes.items() if len(r) == 1]
  single_caves.append("start")
  single_caves.append("end")
  small_caves = [c for c in routes.keys() if is_small(c)]
  return dict(
    (cave, 2)
    for cave in small_caves
  )


def routes_after_vising_cave(routes, max_visits, current_cave):
  if current_cave not in max_visits:
    return routes, max_visits
  max_visits = dict((c,m-1 if c==current_cave else m) for c,m in max_visits.items())
  if max_visits[current_cave] == 0:
    routes = dict(
      (cave, [e for e in exits if e != current_cave])
      for cave,exits in routes.items()
    )
  return routes, max_visits


def can_still_visit(current_cave, max_visits):
  return (
    current_cave not in max_visits or
    max_visits[current_cave] > 0
  )


def find_paths_to_end(routes, max_visits, current_cave, path=()):
  path += (current_cave,)
  if current_cave == "end":
    yield path
  else:
    if can_still_visit(current_cave, max_visits):
      routes, max_visits = routes_after_vising_cave(routes, max_visits, current_cave)
      for next_cave in routes[current_cave]:
        yield from find_paths_to_end(routes, max_visits, next_cave, path)


routes = load_routes("example1.txt")
max_visits = qualify_maximum_visits(routes)
paths = list(find_paths_to_end(routes, max_visits, "start"))

print(len(paths))
print("\n".join(",".join(f) for f in paths))
