inp z         ; z carry from previous digit, named C for safe substitution

inp w         ; *w = $13
mul x 0       ;  x = 0
add x z       ;  x = C
mod x 26      ;  x = C % 26
div z 26      ;  z = C // 26
add x 0       ;  x = C % 26 - 0 
eql x w       ;  x = (C % 26 - 0) == $13
eql x 0       ; *x = (C % 26 - 0) != $13
mul y 0       ;  y = 0
add y 25      ;  y = 25
mul y x       ;  y = 25*((C % 26 - 0) != $13)
add y 1       ;  y = 25*((C % 26 - 0) != $13) + 1
mul z y       ;  z = (C // 26) * (25*((C % 26 - 0) != $13) + 1)
mul y 0       ;  y = 0
add y w       ;  y = $13
add y 3       ;  y = $13 + 3
mul y x       ; *y = ($13 + 3) * ((C % 26 - 0) != $13)
add z y       ; *z = (C // 26) * (25*((C % 26 - 0) != $13) + 1) + ($13 + 3) * ((C % 26 - 0) != $13)
